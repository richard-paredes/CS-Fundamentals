HW4 Due 11:59PM May 07

***There will be no reviews for this Homework***

Feel free to give answers collectively, and also if you want to, you can call 
out something specific to yourself different from your team member.

1. What did you essentially learn in this course about design?

(Richard)
Going into this course, I had almost no knowledge on any design principles or patterns. In fact, I hardly knew the difference between the two. I never followed a test-driven development approach, nor did I place a large emphasis on writing clear, concise, and intentional code. In short, before this class, good software design had little relevance and application to my career as a developer, as much as I dislike to admit it. However, after learning so much more about development approaches, programming paradigms, design principles and patterns, and overall code quality, I feel far better-equipped to design and develop more robust, evolutionary software.

One of the most significant characteristics of this class has been its emphasis on test-driven development (TDD). Through following TDD in every assignment, I have gained a strong understanding of how useful it can really be. TDD helps demystify and solidify details that remain hidden or too abstract to be hashed out during the stages of strategic design. Moreover, TDD helps reduce complexity by placing a focus on code quality. Code is kept minimal, intentional, decoupled, and robust. Additionally, the test cases can serve as a form of documentation and verification, providing developers confidence to refactor and evolve the software. Because of the usefulness of TDD, I have began taking this development approach on most software projects I work on. As a result, I feel much more confident about the software I develop, knowing that thoughtful design has gone into it and it's achieving its purpose.

By gaining a strong understanding on design principles from this class, such as the Open-Closed principle (OCP), Single-Responsibility principle (SRP), Don't Repeat Yourself (DRY), and many more, I have gained a better understanding of metrics affecting code quality. For instance, cohesion, degree of coupling, opacity, stability, rigidity, and various other characteristics play a role in determining whether the software follows a good or bad design. Knowing these metrics keeps me aware of the quality of my own code as I develop and guides me towards better software design.

Lastly, this class has definitely helped me handle critiques and feedback much better. With a focus on incremental and iterative changes, having the ability to request and receive code reviews has had a huge impact on how I have grown as a developer. I previously had limited experience in fruitful code reviews, since most of the time they were just accepted without any positive or critical feedback. However, by having the code reviews introduce new or better strategies to approach problems, I have learned a great amount about proper software design. For example, when to use inheritance versus aggregation, when a design pattern would be useful, and when design principles are not being upheld. There are so many considerations to make at every stage of software development, and this class has provided me a strong foundation to build off of.

(Alan)
Similarly, as Richard, I entered this course with essentially zero knowledge and experience with design principles and design patterns. Upon finding out that we were going to learn about design principles and patterns, I frankly thought these topics would only be discussed in a few lecture videos and we would then move on to some other topics. In prior courses I have taken (engineering and computer science) we would quickly go over some principles and they would essentially be presented as definitions without a clear practical application. However, in this course, to my surprise, I learned that these design principles and patterns really serve as true guides for proper software design. As each design principle and design pattern was clearly presented, I immediately recognized its application and I would think of past experiences where applying certain design patterns could have been incredibly useful and other scenarios where I unknowingly applied certain patterns into the design of my solution. By now having this knowledge of both design principles and design patterns I will iteratively think though my design to ensure I do not violate any design principles and be better able to recognize whether certain design patterns start taking shape in my design and if so then steer my design to ensure the pattern is properly implemented.

An additional takeaway for me from this course was that there is always room for improvement. I know this phrase is very cliché but I found that it was very true in the iterative approach that we took in this course to arriving at a final solution. I use the word “arriving” rather than creating because while we did have an idea of what we wanted the final solution to look like, the solution actually unraveled and took a shape of its own through the use of test-driven development. The unit tests we created would provide us with immediate feedback and stop our approach immediately, if needed, and map us in a better direction towards a more optimal solution. Additionally, the consistent feedback we received throughout the review process helped out tremendously to identify room for improvement and similarly steering us to a better solution. Learning about test-driven development has provided me with solid foundation on setting up and designing my future projects with a feedback loop that will result in a robust and maintainable solution. Furthermore, by receiving the consistent feedback via the review process I have also been able to learn how to provide feedback to others and be a more active member in design review meetings. I am now able to provide relevant feedback such as suggesting following the DRY principle, questioning whether a particular approach violates the Open-Closed Principle or if we should consider applying functional style programming over imperative programming. 

2. What are some of the general guidelines you would follow when designing?

(Alan)
Throughout my experience in this course, I feel like I have acquired several tools in my software design “toolbox” that I will carry with me on every future project I am involved in. One of the great aspects of this course was that everything we learned were methodologies, principles and patterns that can be applied to any software design project, not just the projects we took on in this course. Therefore, every lecture, homework, assignment and review provided us with additional tools for us to apply not only in the current assignment, but in future software design endeavors as well.

One of the main approaches I am currently applying in external projects and will continue to apply is test-driven design. Personally, test-driven design has had a significant impact on my view of testing. Prior to learning about test-driven development, I viewed unit tests as an afterthought and essentially something that needed to be completed after completing the design and implementation. However, I now recognize my ignorance and the disservice I was committing by not taking advantage of the design feedback loop unit tests can provide via test-driven development. Therefore, I will continue to practice implementing test-driven development and exploring the test libraries, as well as learn about approaches others take in their design to really attempt to take full advantage of test-driven development. 

An additional general guideline I will follow is to actually take the time to think though a strategic design prior to typing any code. I have been guilty in the past of being given a project statement and immediately start coding away a solution without really thinking through the design. By actually creating an initial strategic design, I will have a reference point to base any changes off of. One of the advantages of a strategic design is that it forces the consideration of what classes should be included and what their relationships should be with each other. This provides the programmer with a better starting point having considered the current context of the project, and even though the design will likely change via the evolutionary design process and as new information is introduced in the form of requirements, it will be easier to implement having had considered an initial strategic design.

Finally, an additional approach I will continue to apply in my career is this concept of JIT (Just in Time) learning. This is my last semester as a graduate student and honestly, I have considered taking this course for a few semesters, however I always felt like I wasn’t ready, not because I felt like I couldn’t commit the time, but rather because I wasn’t confident in my current software design knowledge base. In my mind I felt like I need to know everything about software design prior to taking the software design course. With this being my last semester, it was now or never so I took the “risk” of taking a course in which I felt was not 100% ready for. However, as I started going through the course, I realized that software design does not have some sort of final destination but is rather an on-going journey in which you have to continuously learn and stay up-to-speed on new libraries, languages, methodologies, approaches, and continuously improve on the implementation of design principles and patterns of new and different use-cases. Therefore, this concept of JIT learning is a very important skill on its own that just like any other skill needs to be worked on and improved upon. While it may not be an “official” guideline, I do feel like JIT and continuous learning is definitely a guiding post to success in the dynamic world of software design.

(Richard)
Taking this course has offered a refreshing take on how to properly design and develop software. We have learned many techniques and strategies at almost every stage of the development cycle. As I continue my career as a developer, there are many guidelines that I have learned through this course that I will follow and take into consideration as I continue to design and develop future software. 

For example, one the first stages, which I have previously overlooked almost every time, is to start with a strategic design. By taking the time to plan before even touching a line of code, the abstract concepts are solidified into manageable elements and forseeable issues can be identified and addressed by consulting with other stakeholders. As I have learned through previous experiences, this stage is very important. Beginning development with a strategic design reduces the likelihood of developing excessively, or even developing something that fails to meet the requirements altogether. 

Another significant technique I plan to follow is test-driven development. Prior to this class, I perceived TDD to be some kind of baseless fad, and unit tests as bonuses rather than foundational. However, practicing TDD on every assignment has completely changed my perspective on it and taught me a lot about its advantages. Similar to the benefits of strategic design, TDD forces developers to design as they develop. Rather than solely focusing on creating software that works, TDD pushes developers into the perspective of the client using the software. As such, aspects like code readability and quality are no longer just afterthoughts but instead focal points. As a result, software developed using TDD tend to follow better designs.

One more guideline that I think is very important and plan to follow is to explore and become more acquainted with the tools being used to develop. For example, prior to this class, I only used Python to develop uncomplicated toy programs. Consequently, I felt I had a weak foundation in this language and its libraries. As we learned interesting strategies through lectures, such as inheriting via interfaces or abstract classes, I was trying to forcefully implement them in the Python program. However, with the fruitful feedback from code reviews, I learned that leveraging the potential of the language could prove more useful. For example, we could exploit Python's dynamic typing to have methods behave more interestingly, or libraries to follow a more functional programming style. Much of my time was spent referring to various documentations, and as a result I felt like I learned so much. In short, each language has its own quirks and ecosystem. Rather than wasting time rejecting these features and trying to force the language into something we are more familiar with, we can find interesting ways to leverage these tools provided to create higher quality code.